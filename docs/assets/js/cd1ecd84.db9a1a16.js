"use strict";(globalThis.webpackChunkai_textbook_docusaurus=globalThis.webpackChunkai_textbook_docusaurus||[]).push([[757],{5849:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var r=t(4848),o=t(8453);const s={sidebar_position:5,title:"Capstone Project - The Autonomous Humanoid"},i="Capstone Project: The Autonomous Humanoid",a={id:"module-4-vla/capstone-project",title:"Capstone Project - The Autonomous Humanoid",description:"The capstone project brings together all the concepts learned in previous modules to create an integrated autonomous humanoid robot system. This project involves implementing a simulated humanoid robot that can receive voice commands, plan paths, navigate obstacles, identify objects, and manipulate them based on user instructions.",source:"@site/docs/module-4-vla/capstone-project.md",sourceDirName:"module-4-vla",slug:"/module-4-vla/capstone-project",permalink:"/physical-ai-humanoid-robotic-text-book/docs/module-4-vla/capstone-project",draft:!1,unlisted:!1,editUrl:"https://github.com/Abdullahkhan90/Physical-AI-Humanoid-Robotic-Text-Book/edit/main/docs/module-4-vla/capstone-project.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Capstone Project - The Autonomous Humanoid"},sidebar:"tutorialSidebar",previous:{title:"Cognitive Planning with LLMs",permalink:"/physical-ai-humanoid-robotic-text-book/docs/module-4-vla/cognitive-planning"}},l={},c=[{value:"Project Overview",id:"project-overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"System Architecture",id:"system-architecture",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"1. Mission Control Node",id:"1-mission-control-node",level:3},{value:"2. Voice Command Processing Component",id:"2-voice-command-processing-component",level:3},{value:"3. Navigation Controller",id:"3-navigation-controller",level:3},{value:"4. Perception System",id:"4-perception-system",level:3},{value:"5. Manipulation Controller",id:"5-manipulation-controller",level:3},{value:"Project Integration and Testing",id:"project-integration-and-testing",level:2},{value:"Main Project Node",id:"main-project-node",level:3},{value:"Testing Scenarios",id:"testing-scenarios",level:2},{value:"Basic Interaction Test",id:"basic-interaction-test",level:3},{value:"Advanced Scenario Test",id:"advanced-scenario-test",level:3},{value:"Safety Considerations",id:"safety-considerations",level:2},{value:"Emergency Stop Integration",id:"emergency-stop-integration",level:3},{value:"Performance Metrics",id:"performance-metrics",level:2},{value:"Evaluation Criteria",id:"evaluation-criteria",level:3},{value:"Logging and Analytics",id:"logging-and-analytics",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"capstone-project-the-autonomous-humanoid",children:"Capstone Project: The Autonomous Humanoid"}),"\n",(0,r.jsx)(n.p,{children:"The capstone project brings together all the concepts learned in previous modules to create an integrated autonomous humanoid robot system. This project involves implementing a simulated humanoid robot that can receive voice commands, plan paths, navigate obstacles, identify objects, and manipulate them based on user instructions."}),"\n",(0,r.jsx)(n.h2,{id:"project-overview",children:"Project Overview"}),"\n",(0,r.jsx)(n.p,{children:"The Autonomous Humanoid capstone project demonstrates the integration of:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 1"}),": ROS 2 communication framework and controller integration"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 2"}),": Simulation environment with Gazebo and perception"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 3"}),": AI-based perception, planning, and navigation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Module 4"}),": Voice command processing and cognitive planning"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"Upon completion of this project, you will be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Integrate multiple ROS 2 nodes into a cohesive autonomous system"}),"\n",(0,r.jsx)(n.li,{children:"Implement voice control with natural language understanding"}),"\n",(0,r.jsx)(n.li,{children:"Plan navigation paths in complex environments"}),"\n",(0,r.jsx)(n.li,{children:"Execute manipulation tasks based on high-level commands"}),"\n",(0,r.jsx)(n.li,{children:"Demonstrate the ability to interact with the environment and perform tasks based on user instructions"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"system-architecture",children:"System Architecture"}),"\n",(0,r.jsx)(n.p,{children:"The autonomous humanoid system architecture consists of these interconnected components:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[User Voice Command] \r\n        \u2193\r\n[Whisper ASR Module] \u2192 [NLP Command Interpreter] \u2192 [Cognitive Planner]\r\n        \u2193                                             \u2193\r\n[Mission Control Node] \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n        \u2193\r\n[Navigation System] \u2192 [Path Planner] \u2192 [Footstep Planner] \u2192 [Motion Controller]\r\n        \u2193                                                     \u2193\r\n[Perception System] \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n        \u2193\r\n[Object Detection] \u2192 [Manipulation Planner] \u2192 [Arm Controller]\r\n        \u2193\r\n[Execution Monitor] \u2192 [Safety Checker] \u2192 [Feedback Generator]\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsx)(n.h3,{id:"1-mission-control-node",children:"1. Mission Control Node"}),"\n",(0,r.jsx)(n.p,{children:"The central hub that coordinates all system components:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom sensor_msgs.msg import Image, PointCloud2\r\nfrom builtin_interfaces.msg import Duration\r\nimport queue\r\nimport threading\r\nimport time\r\n\r\nclass MissionControlNode(Node):\r\n    def __init__(self):\r\n        super().__init__('mission_control')\r\n        \r\n        # Publishers\r\n        self.command_pub = self.create_publisher(String, 'missions/command_input', 10)\r\n        self.goal_pub = self.create_publisher(PoseStamped, 'goal_pose', 10)\r\n        self.voice_response_pub = self.create_publisher(String, 'voice_response', 10)\r\n        \r\n        # Subscribers\r\n        self.voice_cmd_sub = self.create_subscription(\r\n            String, 'voice_command', self.voice_command_callback, 10)\r\n        self.navigation_status_sub = self.create_subscription(\r\n            String, 'navigation_status', self.nav_status_callback, 10)\r\n        self.perception_status_sub = self.create_subscription(\r\n            String, 'perception_status', self.perception_status_callback, 10)\r\n        self.manipulation_status_sub = self.create_subscription(\r\n            String, 'manipulation_status', self.manipulation_status_callback, 10)\r\n        \r\n        # Internal state\r\n        self.current_task = None\r\n        self.task_queue = queue.Queue()\r\n        self.system_status = {\r\n            'navigation': 'idle',\r\n            'perception': 'idle',\r\n            'manipulation': 'idle',\r\n            'voice_interface': 'active'\r\n        }\r\n        \r\n        # Timer for system monitoring\r\n        self.monitor_timer = self.create_timer(1.0, self.system_monitor)\r\n        \r\n        # Initialize subsystem controllers\r\n        self.nav_controller = NavigationController(self)\r\n        self.perception_controller = PerceptionController(self)\r\n        self.manipulation_controller = ManipulationController(self)\r\n        \r\n        self.get_logger().info(\"Mission Control Node initialized\")\r\n    \r\n    def voice_command_callback(self, msg):\r\n        \"\"\"Process incoming voice commands\"\"\"\r\n        self.get_logger().info(f\"Received voice command: {msg.data}\")\r\n        \r\n        # Parse and validate command\r\n        parsed_command = self.parse_command(msg.data)\r\n        if parsed_command:\r\n            # Add to task queue based on parsed command\r\n            self.task_queue.put(parsed_command)\r\n            self.execute_next_task()\r\n        else:\r\n            self.respond_to_user(\"I didn't understand that command. Please try again.\")\r\n    \r\n    def parse_command(self, command_text):\r\n        \"\"\"Parse natural language command into structured task\"\"\"\r\n        command_text = command_text.lower().strip()\r\n        \r\n        # Simple command parsing - in a real system, this would be more sophisticated\r\n        if \"go to\" in command_text and \"kitchen\" in command_text:\r\n            return {\r\n                'type': 'NAVIGATION',\r\n                'destination': 'kitchen',\r\n                'position': self.get_kitchen_location(),\r\n                'action': 'navigate'\r\n            }\r\n        elif \"pick up\" in command_text or \"grab\" in command_text:\r\n            object_name = self.extract_object_name(command_text)\r\n            return {\r\n                'type': 'MANIPULATION',\r\n                'action': 'pick_up',\r\n                'target_object': object_name,\r\n                'destination': None\r\n            }\r\n        elif \"bring\" in command_text and \"me\" in command_text:\r\n            object_name = self.extract_object_name(command_text)\r\n            return {\r\n                'type': 'COMPOSITE',\r\n                'tasks': [\r\n                    {'type': 'NAVIGATION', 'destination': 'object_location', 'target_object': object_name},\r\n                    {'type': 'MANIPULATION', 'action': 'pick_up', 'target_object': object_name},\r\n                    {'type': 'NAVIGATION', 'destination': 'user_location', 'action': 'return'}\r\n                ]\r\n            }\r\n        elif \"clean\" in command_text or \"tidy\" in command_text:\r\n            return {\r\n                'type': 'COMPOSITE',\r\n                'tasks': [\r\n                    {'type': 'PERCEPTION', 'action': 'scan_area', 'scan_target': 'room'},\r\n                    {'type': 'MANIPULATION', 'action': 'collect_items', 'item_types': self.get_cleanable_items()},\r\n                    {'type': 'NAVIGATION', 'destination': 'disposal_area', 'action': 'deposit_items'}\r\n                ]\r\n            }\r\n        \r\n        # Default: unrecognized command\r\n        self.respond_to_user(f\"I don't know how to '{command_text}'. Can you rephrase?\")\r\n        return None\r\n    \r\n    def execute_next_task(self):\r\n        \"\"\"Execute the next task in the queue\"\"\"\r\n        if not self.task_queue.empty():\r\n            task = self.task_queue.get()\r\n            \r\n            self.get_logger().info(f\"Executing task: {task['type']}\")\r\n            \r\n            if task['type'] == 'NAVIGATION':\r\n                self.nav_controller.execute_navigation_task(task)\r\n            elif task['type'] == 'MANIPULATION':\r\n                self.manipulation_controller.execute_manipulation_task(task)\r\n            elif task['type'] == 'PERCEPTION':\r\n                self.perception_controller.execute_perception_task(task)\r\n            elif task['type'] == 'COMPOSITE':\r\n                self.execute_composite_task(task)\r\n    \r\n    def execute_composite_task(self, composite_task):\r\n        \"\"\"Execute a sequence of related tasks\"\"\"\r\n        for subtask in composite_task['tasks']:\r\n            # Execute each subtask and wait for completion before proceeding\r\n            self.wait_for_task_completion(subtask)\r\n    \r\n    def wait_for_task_completion(self, task):\r\n        \"\"\"Wait for a specific task to complete\"\"\"\r\n        # This would involve checking the system status and possibly timeouts\r\n        timeout = time.time() + 30  # 30 second timeout\r\n        while self.system_status[self.get_component_for_task(task)] != 'completed':\r\n            if time.time() > timeout:\r\n                self.get_logger().error(f\"Task timed out: {task}\")\r\n                return False\r\n            time.sleep(0.1)\r\n        return True\r\n    \r\n    def get_component_for_task(self, task):\r\n        \"\"\"Get the system component responsible for a task\"\"\"\r\n        if task['type'] == 'NAVIGATION':\r\n            return 'navigation'\r\n        elif task['type'] == 'MANIPULATION':\r\n            return 'manipulation'\r\n        elif task['type'] == 'PERCEPTION':\r\n            return 'perception'\r\n        return 'voice_interface'\r\n    \r\n    def nav_status_callback(self, msg):\r\n        \"\"\"Update navigation status\"\"\"\r\n        self.system_status['navigation'] = msg.data\r\n        self.get_logger().info(f\"Navigation status: {msg.data}\")\r\n    \r\n    def perception_status_callback(self, msg):\r\n        \"\"\"Update perception status\"\"\"\r\n        self.system_status['perception'] = msg.data\r\n        self.get_logger().info(f\"Perception status: {msg.data}\")\r\n    \r\n    def manipulation_status_callback(self, msg):\r\n        \"\"\"Update manipulation status\"\"\"\r\n        self.system_status['manipulation'] = msg.data\r\n        self.get_logger().info(f\"Manipulation status: {msg.data}\")\r\n    \r\n    def system_monitor(self):\r\n        \"\"\"Monitor system health and status\"\"\"\r\n        # Check if all subsystems are responsive\r\n        for component, status in self.system_status.items():\r\n            if status == 'error':\r\n                self.get_logger().error(f\"{component} system is in error state\")\r\n                # Handle error condition\r\n        \r\n        # Log system status periodically\r\n        self.get_logger().debug(f\"System status: {self.system_status}\")\r\n    \r\n    def respond_to_user(self, response_text):\r\n        \"\"\"Provide vocal response to user\"\"\"\r\n        response_msg = String()\r\n        response_msg.data = response_text\r\n        self.voice_response_pub.publish(response_msg)\r\n        self.get_logger().info(f\"Responding to user: {response_text}\")\r\n    \r\n    def get_kitchen_location(self):\r\n        \"\"\"Get pre-defined kitchen location\"\"\"\r\n        # In a real system, this would come from a map or semantic navigation system\r\n        pose = PoseStamped()\r\n        pose.header.frame_id = 'map'\r\n        pose.pose.position.x = 3.0\r\n        pose.pose.position.y = 2.0\r\n        pose.pose.orientation.w = 1.0\r\n        return pose\r\n    \r\n    def extract_object_name(self, command):\r\n        \"\"\"Extract object name from command (simple implementation)\"\"\"\r\n        # This is a simplified extraction - a real implementation would use more sophisticated NLP\r\n        objects = ['cup', 'bottle', 'book', 'toy', 'phone', 'keys', 'glasses', 'hat']\r\n        for obj in objects:\r\n            if obj in command:\r\n                return obj\r\n        return 'unknown_object'\r\n    \r\n    def get_cleanable_items(self):\r\n        \"\"\"Get list of items that can be cleaned/tidied\"\"\"\r\n        return ['cup', 'book', 'toy', 'hat', 'glasses']\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-voice-command-processing-component",children:"2. Voice Command Processing Component"}),"\n",(0,r.jsx)(n.p,{children:"Implementing the voice processing pipeline:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import openai\r\nimport speech_recognition as sr\r\nimport pyttsx3\r\nimport threading\r\n\r\nclass VoiceInterface:\r\n    def __init__(self, mission_control_node):\r\n        self.mission_control = mission_control_node\r\n        \r\n        # Initialize speech recognition\r\n        self.recognizer = sr.Recognizer()\r\n        self.microphone = sr.Microphone()\r\n        \r\n        # Initialize text-to-speech\r\n        self.tts_engine = pyttsx3.init()\r\n        self.setup_tts()\r\n        \r\n        # Setup Whisper API\r\n        self.whisper_api_key = self.mission_control.get_parameter_or(\r\n            \'whisper_api_key\', \'sk-xxxxx\').value\r\n        \r\n        # Start listening thread\r\n        self.listening_active = True\r\n        self.listening_thread = threading.Thread(target=self.continuous_listening)\r\n        self.listening_thread.daemon = True\r\n        self.listening_thread.start()\r\n    \r\n    def setup_tts(self):\r\n        """Configure text-to-speech parameters"""\r\n        voices = self.tts_engine.getProperty(\'voices\')\r\n        self.tts_engine.setProperty(\'rate\', 150)  # Speed of speech\r\n        self.tts_engine.setProperty(\'volume\', 0.9)  # Volume level (0.0 to 1.0)\r\n        \r\n        # Try to use female voice if available (often sounds more natural for responses)\r\n        for voice in voices:\r\n            if "female" in voice.name.lower() or "zira" in voice.name.lower():\r\n                self.tts_engine.setProperty(\'voice\', voice.id)\r\n                break\r\n    \r\n    def continuous_listening(self):\r\n        """Continuously listen for voice commands"""\r\n        with self.microphone as source:\r\n            # Adjust for ambient noise\r\n            self.mission_control.get_logger().info("Adjusting for ambient noise...")\r\n            self.recognizer.adjust_for_ambient_noise(source)\r\n            self.mission_control.get_logger().info("Listening for commands...")\r\n        \r\n        while self.listening_active:\r\n            try:\r\n                # Listen for audio\r\n                with self.microphone as source:\r\n                    audio = self.recognizer.listen(source, timeout=1.0, phrase_time_limit=5)\r\n                \r\n                # Process audio with Whisper\r\n                command_text = self.process_audio_with_whisper(audio)\r\n                \r\n                if command_text:\r\n                    # Publish command to ROS system\r\n                    self.publish_command(command_text)\r\n                \r\n            except sr.WaitTimeoutError:\r\n                # Normal - no speech detected within timeout\r\n                continue\r\n            except sr.UnknownValueError:\r\n                # Speech was detected but not understood\r\n                self.mission_control.get_logger().info("Could not understand audio")\r\n                self.speak_response("I didn\'t catch that. Could you repeat?")\r\n            except Exception as e:\r\n                self.mission_control.get_logger().error(f"Error in voice processing: {e}")\r\n                self.speak_response("I\'m having trouble listening right now.")\r\n    \r\n    def process_audio_with_whisper(self, audio_data):\r\n        """Process audio using OpenAI Whisper"""\r\n        try:\r\n            # Save audio to temporary file\r\n            with open("/tmp/temp_audio.wav", "wb") as f:\r\n                f.write(audio_data.get_wav_data())\r\n            \r\n            # Use Whisper API to transcribe\r\n            openai.api_key = self.whisper_api_key\r\n            with open("/tmp/temp_audio.wav", "rb") as audio_file:\r\n                transcript = openai.Audio.transcribe("whisper-1", audio_file)\r\n            \r\n            command_text = transcript.text.strip()\r\n            self.mission_control.get_logger().info(f"Transcribed: {command_text}")\r\n            \r\n            return command_text\r\n        except Exception as e:\r\n            self.mission_control.get_logger().error(f"Whisper processing error: {e}")\r\n            return None\r\n    \r\n    def publish_command(self, command_text):\r\n        """Publish recognized command to ROS system"""\r\n        from std_msgs.msg import String\r\n        cmd_msg = String()\r\n        cmd_msg.data = command_text\r\n        self.mission_control.voice_cmd_sub.publish(cmd_msg)\r\n    \r\n    def speak_response(self, text):\r\n        """Speak response to user"""\r\n        self.mission_control.get_logger().info(f"Speaking response: {text}")\r\n        \r\n        def speak_thread():\r\n            self.tts_engine.say(text)\r\n            self.tts_engine.runAndWait()\r\n        \r\n        # Speak in a separate thread to avoid blocking\r\n        speak_thread = threading.Thread(target=speak_thread)\r\n        speak_thread.daemon = True\r\n        speak_thread.start()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"3-navigation-controller",children:"3. Navigation Controller"}),"\n",(0,r.jsx)(n.p,{children:"Implementing the path planning and navigation system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from nav2_simple_commander.robot_navigator import BasicNavigator\r\nfrom geometry_msgs.msg import PoseStamped, Point\r\nfrom std_msgs.msg import String\r\nimport math\r\n\r\nclass NavigationController:\r\n    def __init__(self, mission_control_node):\r\n        self.mission_control = mission_control_node\r\n        self.navigator = BasicNavigator()\r\n        self.navigator.waitUntilNav2Active()\r\n        \r\n        # Publisher for navigation status\r\n        self.nav_status_pub = self.mission_control.create_publisher(\r\n            String, 'navigation_status', 10)\r\n        \r\n        self.current_destination = None\r\n        self.path_following_active = False\r\n    \r\n    def execute_navigation_task(self, task):\r\n        \"\"\"Execute a navigation task\"\"\"\r\n        self.mission_control.get_logger().info(f\"Navigating to: {task['destination']}\")\r\n        \r\n        # Update status\r\n        self.update_navigation_status('navigating')\r\n        \r\n        # Create destination pose\r\n        goal_pose = PoseStamped()\r\n        goal_pose.header.frame_id = 'map'\r\n        goal_pose.header.stamp = self.mission_control.get_clock().now().to_msg()\r\n        \r\n        if 'position' in task:\r\n            goal_pose.pose.position.x = task['position'].pose.position.x\r\n            goal_pose.pose.position.y = task['position'].pose.position.y\r\n            goal_pose.pose.orientation.w = 1.0\r\n        else:\r\n            # Use predefined locations\r\n            loc = self.get_predefined_location(task['destination'])\r\n            if loc:\r\n                goal_pose.pose.position.x = loc[0]\r\n                goal_pose.pose.position.y = loc[1]\r\n                goal_pose.pose.orientation.w = loc[2]\r\n            else:\r\n                self.mission_control.get_logger().error(f\"Unknown destination: {task['destination']}\")\r\n                self.update_navigation_status('error')\r\n                return False\r\n        \r\n        # Navigate to goal\r\n        self.navigator.goToPose(goal_pose)\r\n        \r\n        # Monitor navigation progress\r\n        while not self.navigator.isTaskComplete():\r\n            # Check for cancellation\r\n            feedback = self.navigator.getFeedback()\r\n            if feedback:\r\n                # Calculate remaining distance\r\n                current_pose = self.navigator.getRobotPose()\r\n                remaining_distance = self.calculate_distance(\r\n                    current_pose.position, \r\n                    goal_pose.pose.position\r\n                )\r\n                \r\n                # Log progress\r\n                if remaining_distance < 0.5:\r\n                    self.mission_control.get_logger().info(\"Approaching destination\")\r\n        \r\n        # Check completion result\r\n        result = self.navigator.getResult()\r\n        if result == TaskResult.SUCCEEDED:\r\n            self.mission_control.get_logger().info(f\"Successfully reached {task['destination']}\")\r\n            self.update_navigation_status('completed')\r\n            return True\r\n        else:\r\n            self.mission_control.get_logger().error(f\"Failed to reach {task['destination']}\")\r\n            self.update_navigation_status('failed')\r\n            return False\r\n    \r\n    def calculate_distance(self, pos1, pos2):\r\n        \"\"\"Calculate Euclidean distance between two points\"\"\"\r\n        dx = pos2.x - pos1.x\r\n        dy = pos2.y - pos1.y\r\n        return math.sqrt(dx*dx + dy*dy)\r\n    \r\n    def get_predefined_location(self, location_name):\r\n        \"\"\"Get predefined location coordinates\"\"\"\r\n        locations = {\r\n            'kitchen': [3.0, 2.0, 0.0],\r\n            'living_room': [0.0, 0.0, 0.0],\r\n            'bedroom': [-2.0, 1.5, 0.0],\r\n            'office': [1.5, -2.0, 0.0],\r\n            'dining_room': [2.0, -1.0, 0.0]\r\n        }\r\n        return locations.get(location_name.lower())\r\n    \r\n    def update_navigation_status(self, status):\r\n        \"\"\"Update navigation system status\"\"\"\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.nav_status_pub.publish(status_msg)\r\n        \r\n        # Also update in mission control\r\n        self.mission_control.system_status['navigation'] = status\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-perception-system",children:"4. Perception System"}),"\n",(0,r.jsx)(n.p,{children:"Implementing the perception and object detection:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import cv2\r\nimport numpy as np\r\nfrom sensor_msgs.msg import Image\r\nfrom cv_bridge import CvBridge\r\nfrom std_msgs.msg import String\r\nimport tensorflow as tf\r\n\r\nclass PerceptionController:\r\n    def __init__(self, mission_control_node):\r\n        self.mission_control = mission_control_node\r\n        self.cv_bridge = CvBridge()\r\n        \r\n        # Subscriber for camera feed\r\n        self.camera_sub = self.mission_control.create_subscription(\r\n            Image, '/robot_head_camera/image_raw', self.camera_callback, 10)\r\n        \r\n        # Publisher for perception status\r\n        self.perception_status_pub = self.mission_control.create_publisher(\r\n            String, 'perception_status', 10)\r\n        \r\n        # Load object detection model\r\n        self.load_detection_model()\r\n        \r\n        # Current camera image\r\n        self.current_image = None\r\n        self.detection_active = False\r\n        \r\n        # Detected objects cache\r\n        self.detected_objects = []\r\n    \r\n    def load_detection_model(self):\r\n        \"\"\"Load the object detection model\"\"\"\r\n        # In a real system, this would load a trained model like YOLO or SSD\r\n        # For this example, we'll simulate detection\r\n        self.detection_model = None  # Placeholder\r\n        self.mission_control.get_logger().info(\"Perception model loaded\")\r\n    \r\n    def camera_callback(self, msg):\r\n        \"\"\"Process incoming camera images\"\"\"\r\n        try:\r\n            # Convert ROS Image message to OpenCV image\r\n            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\r\n            self.current_image = cv_image\r\n            \r\n            # If detection is active, process the image\r\n            if self.detection_active:\r\n                self.process_image_for_detection(cv_image)\r\n        except Exception as e:\r\n            self.mission_control.get_logger().error(f\"Camera callback error: {e}\")\r\n    \r\n    def process_image_for_detection(self, image):\r\n        \"\"\"Run object detection on the image\"\"\"\r\n        # In a real system, this would run the loaded model\r\n        # For simulation, we'll detect some predefined objects\r\n        detected_objects = self.simulate_object_detection(image)\r\n        \r\n        if detected_objects:\r\n            self.detected_objects = detected_objects\r\n            self.mission_control.get_logger().info(f\"Detected objects: {[obj['name'] for obj in detected_objects]}\")\r\n    \r\n    def simulate_object_detection(self, image):\r\n        \"\"\"Simulate object detection for the project\"\"\"\r\n        # This is a simulation - in a real system, this would use an actual detection model\r\n        # For demo purposes, we'll return some predefined objects\r\n        height, width = image.shape[:2]\r\n        \r\n        # Predefined objects with positions\r\n        objects = [\r\n            {\r\n                'name': 'red_cup',\r\n                'bbox': [int(width*0.3), int(height*0.4), int(width*0.4), int(height*0.5)],\r\n                'confidence': 0.92,\r\n                'center': (int(width*0.35), int(height*0.45)),\r\n                'position_3d': self.estimate_3d_position([int(width*0.35), int(height*0.45)])\r\n            },\r\n            {\r\n                'name': 'blue_book',\r\n                'bbox': [int(width*0.6), int(height*0.5), int(width*0.7), int(height*0.6)],\r\n                'confidence': 0.87,\r\n                'center': (int(width*0.65), int(height*0.55)),\r\n                'position_3d': self.estimate_3d_position([int(width*0.65), int(height*0.55)])\r\n            }\r\n        ]\r\n        \r\n        return objects\r\n    \r\n    def estimate_3d_position(self, pixel_coords):\r\n        \"\"\"Estimate 3D position from 2D pixel coordinates\"\"\"\r\n        # Rough estimation - in a real system this would use depth information\r\n        # For simulation purposes:\r\n        return {\r\n            'x': (pixel_coords[0] - 320) * 0.002,  # Approximate conversion from pixels to meters\r\n            'y': (240 - pixel_coords[1]) * 0.002,  # Invert Y axis\r\n            'z': 1.0  # Assume object is 1 meter away\r\n        }\r\n    \r\n    def execute_perception_task(self, task):\r\n        \"\"\"Execute a perception-related task\"\"\"\r\n        self.mission_control.get_logger().info(f\"Executing perception task: {task['action']}\")\r\n        \r\n        self.update_perception_status('processing')\r\n        \r\n        if task['action'] == 'scan_area':\r\n            # Actively scan surroundings for objects\r\n            self.detection_active = True\r\n            \r\n            # Wait for detections (in simulation, we'll just wait a bit)\r\n            import time\r\n            time.sleep(2)\r\n            \r\n            # Return detection results\r\n            detection_results = {\r\n                'objects_found': [obj['name'] for obj in self.detected_objects],\r\n                'object_details': self.detected_objects\r\n            }\r\n            \r\n            self.mission_control.get_logger().info(f\"Perception results: {detection_results}\")\r\n            self.update_perception_status('completed')\r\n            \r\n            return detection_results\r\n        elif task['action'] == 'locate_object':\r\n            # Find a specific object\r\n            target_obj = task.get('target_object', 'unknown')\r\n            \r\n            # Look for object in cached detections\r\n            for obj in self.detected_objects:\r\n                if target_obj in obj['name']:\r\n                    self.mission_control.get_logger().info(f\"Located {target_obj}\")\r\n                    return obj\r\n            \r\n            self.mission_control.get_logger().info(f\"{target_obj} not found in view\")\r\n            return None\r\n    \r\n    def update_perception_status(self, status):\r\n        \"\"\"Update perception system status\"\"\"\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.perception_status_pub.publish(status_msg)\r\n        \r\n        # Update mission control\r\n        self.mission_control.system_status['perception'] = status\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-manipulation-controller",children:"5. Manipulation Controller"}),"\n",(0,r.jsx)(n.p,{children:"Implementing the manipulation system:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\r\nfrom sensor_msgs.msg import JointState\r\nfrom std_msgs.msg import String\r\nimport math\r\n\r\nclass ManipulationController:\r\n    def __init__(self, mission_control_node):\r\n        self.mission_control = mission_control_node\r\n        \r\n        # Publishers for manipulation commands\r\n        self.arm_controller_pub = self.mission_control.create_publisher(\r\n            JointTrajectory, '/arm_controller/joint_trajectory', 10)\r\n        self.gripper_controller_pub = self.mission_control.create_publisher(\r\n            JointTrajectory, '/gripper_controller/joint_trajectory', 10)\r\n        \r\n        # Publisher for manipulation status\r\n        self.manip_status_pub = self.mission_control.create_publisher(\r\n            String, 'manipulation_status', 10)\r\n        \r\n        # Subscriber for joint states\r\n        self.joint_state_sub = self.mission_control.create_subscription(\r\n            JointState, '/joint_states', self.joint_state_callback, 10)\r\n        \r\n        # Current joint states\r\n        self.current_joints = {}\r\n        \r\n        # Robot kinematics parameters (simplified)\r\n        self.link_lengths = {\r\n            'upper_arm': 0.3,\r\n            'forearm': 0.25\r\n        }\r\n    \r\n    def joint_state_callback(self, msg):\r\n        \"\"\"Update current joint states\"\"\"\r\n        for name, position in zip(msg.name, msg.position):\r\n            self.current_joints[name] = position\r\n    \r\n    def execute_manipulation_task(self, task):\r\n        \"\"\"Execute a manipulation task\"\"\"\r\n        self.mission_control.get_logger().info(f\"Executing manipulation: {task['action']}\")\r\n        \r\n        self.update_manipulation_status('executing')\r\n        \r\n        if task['action'] == 'pick_up':\r\n            # Locate the target object\r\n            target_obj = task['target_object']\r\n            \r\n            # In a real system, this would get the 3D position from perception\r\n            # For simulation, we'll use a default position\r\n            target_position = self.get_default_object_position(target_obj)\r\n            \r\n            # Plan and execute pick motion\r\n            success = self.execute_pick_motion(target_position)\r\n            \r\n            if success:\r\n                self.mission_control.get_logger().info(f\"Successfully picked up {target_obj}\")\r\n                self.update_manipulation_status('completed')\r\n                return True\r\n            else:\r\n                self.mission_control.get_logger().error(f\"Failed to pick up {target_obj}\")\r\n                self.update_manipulation_status('failed')\r\n                return False\r\n        \r\n        elif task['action'] == 'place':\r\n            # Place object at specified location\r\n            place_position = task.get('destination', self.get_default_place_position())\r\n            success = self.execute_place_motion(place_position)\r\n            \r\n            if success:\r\n                self.mission_control.get_logger().info(\"Object placed successfully\")\r\n                self.update_manipulation_status('completed')\r\n                return True\r\n            else:\r\n                self.mission_control.get_logger().error(\"Failed to place object\")\r\n                self.update_manipulation_status('failed')\r\n                return False\r\n        \r\n        return False\r\n    \r\n    def get_default_object_position(self, obj_name):\r\n        \"\"\"Get default position for a known object\"\"\"\r\n        # In a real system, this would come from perception\r\n        default_positions = {\r\n            'cup': {'x': 0.5, 'y': 0.2, 'z': 0.8},\r\n            'book': {'x': 0.6, 'y': -0.1, 'z': 0.8},\r\n            'toy': {'x': 0.4, 'y': 0.0, 'z': 0.8}\r\n        }\r\n        return default_positions.get(obj_name, {'x': 0.5, 'y': 0.0, 'z': 0.8})\r\n    \r\n    def get_default_place_position(self):\r\n        \"\"\"Get default placement position\"\"\"\r\n        return {'x': 0.0, 'y': -0.5, 'z': 0.8}  # Place on a surface in front\r\n    \r\n    def execute_pick_motion(self, target_position):\r\n        \"\"\"Execute motion sequence to pick up an object\"\"\"\r\n        try:\r\n            # Calculate inverse kinematics\r\n            joint_angles = self.inverse_kinematics(\r\n                target_position['x'], \r\n                target_position['y'], \r\n                target_position['z']\r\n            )\r\n            \r\n            if joint_angles is None:\r\n                self.mission_control.get_logger().error(\"IK solution not found\")\r\n                return False\r\n            \r\n            # Open gripper\r\n            self.open_gripper()\r\n            \r\n            # Move to position above object\r\n            approach_pos = {\r\n                'x': target_position['x'],\r\n                'y': target_position['y'],\r\n                'z': target_position['z'] + 0.1  # 10cm above object\r\n            }\r\n            approach_angles = self.inverse_kinematics(\r\n                approach_pos['x'], approach_pos['y'], approach_pos['z'])\r\n            \r\n            if approach_angles:\r\n                self.move_arm_to_joints(approach_angles)\r\n            \r\n            # Move down to object\r\n            self.move_arm_to_joints(joint_angles)\r\n            \r\n            # Close gripper to grasp object\r\n            self.close_gripper()\r\n            \r\n            # Lift object slightly\r\n            lift_pos = {\r\n                'x': target_position['x'],\r\n                'y': target_position['y'],\r\n                'z': target_position['z'] + 0.15\r\n            }\r\n            lift_angles = self.inverse_kinematics(\r\n                lift_pos['x'], lift_pos['y'], lift_pos['z'])\r\n            \r\n            if lift_angles:\r\n                self.move_arm_to_joints(lift_angles)\r\n            \r\n            return True\r\n            \r\n        except Exception as e:\r\n            self.mission_control.get_logger().error(f\"Error in pick motion: {e}\")\r\n            return False\r\n    \r\n    def execute_place_motion(self, place_position):\r\n        \"\"\"Execute motion sequence to place an object\"\"\"\r\n        try:\r\n            # Calculate inverse kinematics for placement position\r\n            joint_angles = self.inverse_kinematics(\r\n                place_position['x'], \r\n                place_position['y'], \r\n                place_position['z']\r\n            )\r\n            \r\n            if joint_angles is None:\r\n                self.mission_control.get_logger().error(\"IK solution not found for placement\")\r\n                return False\r\n            \r\n            # Move to placement position\r\n            self.move_arm_to_joints(joint_angles)\r\n            \r\n            # Open gripper to release object\r\n            self.open_gripper()\r\n            \r\n            # Move arm away from placed object\r\n            retract_pos = {\r\n                'x': place_position['x'],\r\n                'y': place_position['y'] - 0.1,  # Move backward\r\n                'z': place_position['z'] + 0.1   # Move up slightly\r\n            }\r\n            retract_angles = self.inverse_kinematics(\r\n                retract_pos['x'], retract_pos['y'], retract_pos['z'])\r\n            \r\n            if retract_angles:\r\n                self.move_arm_to_joints(retract_angles)\r\n            \r\n            return True\r\n            \r\n        except Exception as e:\r\n            self.mission_control.get_logger().error(f\"Error in place motion: {e}\")\r\n            return False\r\n    \r\n    def inverse_kinematics(self, x, y, z):\r\n        \"\"\"Simple 2D inverse kinematics for planar arm\"\"\"\r\n        # Simplified 2-joint inverse kinematics\r\n        # This is a greatly simplified version - real IK would be more complex\r\n        try:\r\n            # Calculate distance from origin to target\r\n            dist_sq = x*x + y*y\r\n            dist = math.sqrt(dist_sq)\r\n            \r\n            # Check reachability\r\n            arm_length = self.link_lengths['upper_arm'] + self.link_lengths['forearm']\r\n            if dist > arm_length:\r\n                return None  # Target not reachable\r\n            \r\n            # Calculate joint angles\r\n            upper_length = self.link_lengths['upper_arm']\r\n            forearm_length = self.link_lengths['forearm']\r\n            \r\n            # Cosine law to find elbow angle\r\n            cos_angle_elbow = (upper_length*upper_length + forearm_length*forearm_length - dist_sq) / (2 * upper_length * forearm_length)\r\n            angle_elbow = math.acos(cos_angle_elbow)\r\n            \r\n            # Calculate shoulder angle\r\n            k1 = upper_length + forearm_length * math.cos(angle_elbow)\r\n            k2 = forearm_length * math.sin(angle_elbow)\r\n            \r\n            angle_shoulder = math.atan2(y, x) - math.atan2(k2, k1)\r\n            \r\n            # Return joint angles (shoulder, elbow)\r\n            return [angle_shoulder, math.pi - angle_elbow]\r\n            \r\n        except Exception as e:\r\n            self.mission_control.get_logger().error(f\"IK calculation error: {e}\")\r\n            return None\r\n    \r\n    def move_arm_to_joints(self, joint_angles):\r\n        \"\"\"Move arm to specified joint angles\"\"\"\r\n        traj_msg = JointTrajectory()\r\n        traj_msg.joint_names = ['shoulder_joint', 'elbow_joint']  # Simplified\r\n        \r\n        point = JointTrajectoryPoint()\r\n        point.positions = joint_angles\r\n        point.time_from_start.sec = 2  # 2 seconds to reach position\r\n        \r\n        traj_msg.points.append(point)\r\n        \r\n        self.arm_controller_pub.publish(traj_msg)\r\n        \r\n        # Wait for execution to complete (simplified)\r\n        import time\r\n        time.sleep(2.5)\r\n    \r\n    def open_gripper(self):\r\n        \"\"\"Open the gripper\"\"\"\r\n        traj_msg = JointTrajectory()\r\n        traj_msg.joint_names = ['gripper_joint']\r\n        \r\n        point = JointTrajectoryPoint()\r\n        point.positions = [0.05]  # Open position\r\n        point.time_from_start.sec = 1\r\n        \r\n        traj_msg.points.append(point)\r\n        self.gripper_controller_pub.publish(traj_msg)\r\n        \r\n        import time\r\n        time.sleep(1.2)\r\n    \r\n    def close_gripper(self):\r\n        \"\"\"Close the gripper to grasp\"\"\"\r\n        traj_msg = JointTrajectory()\r\n        traj_msg.joint_names = ['gripper_joint']\r\n        \r\n        point = JointTrajectoryPoint()\r\n        point.positions = [0.01]  # Closed position\r\n        point.time_from_start.sec = 1\r\n        \r\n        traj_msg.points.append(point)\r\n        self.gripper_controller_pub.publish(traj_msg)\r\n        \r\n        import time\r\n        time.sleep(1.2)\r\n    \r\n    def update_manipulation_status(self, status):\r\n        \"\"\"Update manipulation system status\"\"\"\r\n        status_msg = String()\r\n        status_msg.data = status\r\n        self.manip_status_pub.publish(status_msg)\r\n        \r\n        # Update mission control\r\n        self.mission_control.system_status['manipulation'] = status\n"})}),"\n",(0,r.jsx)(n.h2,{id:"project-integration-and-testing",children:"Project Integration and Testing"}),"\n",(0,r.jsx)(n.h3,{id:"main-project-node",children:"Main Project Node"}),"\n",(0,r.jsx)(n.p,{children:"Combine all components in the main project node:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\ndef main():\r\n    rclpy.init()\r\n    \r\n    # Create mission control node\r\n    mission_control = MissionControlNode()\r\n    \r\n    # Initialize subsystems\r\n    voice_interface = VoiceInterface(mission_control)\r\n    nav_controller = NavigationController(mission_control)\r\n    perception_controller = PerceptionController(mission_control)\r\n    manipulation_controller = ManipulationController(mission_control)\r\n    \r\n    # Start the system\r\n    mission_control.get_logger().info("Autonomous Humanoid System Online")\r\n    mission_control.respond_to_user("System is ready. Please give me a command.")\r\n    \r\n    try:\r\n        rclpy.spin(mission_control)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        mission_control.listening_active = False\r\n        mission_control.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"testing-scenarios",children:"Testing Scenarios"}),"\n",(0,r.jsx)(n.h3,{id:"basic-interaction-test",children:"Basic Interaction Test"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Voice Command"}),': "Robot, go to the kitchen"']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validates: Voice recognition \u2192 Command parsing \u2192 Navigation"}),"\n",(0,r.jsx)(n.li,{children:"Expected: Robot navigates to kitchen area"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Voice Command"}),': "Pick up the red cup"']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validates: Perceptio\u2192 Object recognition \u2192 Manipulation"}),"\n",(0,r.jsx)(n.li,{children:"Expected: Robot locates and grasps the cup"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Voice Command"}),': "Bring me the cup"']}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Validates: Composite task execution"}),"\n",(0,r.jsx)(n.li,{children:"Expected: Robot retrieves cup and brings it to user"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"advanced-scenario-test",children:"Advanced Scenario Test"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scenario"}),': "Please clean up the living room by putting books and toys on the shelf"']}),"\n",(0,r.jsx)(n.p,{children:"This complex command should trigger:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Navigation to living room"}),"\n",(0,r.jsx)(n.li,{children:"Area scanning to identify books and toys"}),"\n",(0,r.jsx)(n.li,{children:"Sequential picking up of identified objects"}),"\n",(0,r.jsx)(n.li,{children:"Navigation to shelf location"}),"\n",(0,r.jsx)(n.li,{children:"Placing objects on shelf appropriately"}),"\n",(0,r.jsx)(n.li,{children:"Returning to home position"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"emergency-stop-integration",children:"Emergency Stop Integration"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class SafetyController:\r\n    def __init__(self, mission_control_node):\r\n        self.mission_control = mission_control_node\r\n        self.emergency_stop_sub = self.mission_control.create_subscription(\r\n            String, \'emergency_stop\', self.emergency_stop_callback, 10)\r\n        self.system_armed = True\r\n        \r\n    def emergency_stop_callback(self, msg):\r\n        """Handle emergency stop commands"""\r\n        if msg.data == \'EMERGENCY_STOP\':\r\n            self.trigger_emergency_stop()\r\n    \r\n    def trigger_emergency_stop(self):\r\n        """Safely halt all robot motion"""\r\n        self.mission_control.get_logger().error("EMERGENCY STOP TRIGGERED")\r\n        self.system_armed = False\r\n        \r\n        # Stop all motion\r\n        self.stop_all_motion()\r\n        \r\n        # Move to safe position if possible\r\n        self.move_to_safe_position()\r\n        \r\n    def check_safety_conditions(self):\r\n        """Check if it\'s safe to continue operations"""\r\n        # Check for obstacles\r\n        # Check robot health\r\n        # Check environment safety\r\n        return self.system_armed\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,r.jsx)(n.h3,{id:"evaluation-criteria",children:"Evaluation Criteria"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task Completion Rate"}),": Percentage of commands successfully executed"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Response Time"}),": Time from command receipt to start of execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Navigation Accuracy"}),": Precision of reaching goal locations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Object Manipulation Success"}),": Successful grasping and placement ratio"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Voice Recognition Accuracy"}),": Correct understanding of commands"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"System Recovery"}),": Ability to recover from errors"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"logging-and-analytics",children:"Logging and Analytics"}),"\n",(0,r.jsx)(n.p,{children:"Implement comprehensive logging to track system performance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class SystemAnalytics:\r\n    def __init__(self, mission_control_node):\r\n        self.mission_control = mission_control_node\r\n        self.session_start_time = None\r\n        self.commands_processed = 0\r\n        self.success_count = 0\r\n        self.error_count = 0\r\n        \r\n    def log_command(self, command, result):\r\n        \"\"\"Log command processing results\"\"\"\r\n        self.commands_processed += 1\r\n        if result:\r\n            self.success_count += 1\r\n        else:\r\n            self.error_count += 1\r\n        \r\n        # Log to file for analysis\r\n        self.write_to_logfile(command, result)\r\n    \r\n    def get_performance_stats(self):\r\n        \"\"\"Return current performance metrics\"\"\"\r\n        total_time = time.time() - self.session_start_time if self.session_start_time else 0\r\n        \r\n        return {\r\n            'total_commands': self.commands_processed,\r\n            'successful_commands': self.success_count,\r\n            'error_count': self.error_count,\r\n            'success_rate': self.success_count / self.commands_processed if self.commands_processed > 0 else 0,\r\n            'session_duration': total_time,\r\n            'commands_per_minute': self.commands_processed / (total_time / 60) if total_time > 0 else 0\r\n        }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"The Autonomous Humanoid capstone project demonstrates the integration of all the concepts covered in this textbook. It showcases how voice commands can be processed through an AI system to generate robot behaviors, how navigation systems guide the robot through environments, how perception systems identify objects, and how manipulation systems interact with the physical world."}),"\n",(0,r.jsx)(n.p,{children:"Successfully completing this project requires:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Integration of multiple ROS 2 nodes and subsystems"}),"\n",(0,r.jsx)(n.li,{children:"Proper handling of concurrency and asynchronous operations"}),"\n",(0,r.jsx)(n.li,{children:"Implementation of safety considerations and error recovery"}),"\n",(0,r.jsx)(n.li,{children:"Design of a user-friendly interaction model"}),"\n",(0,r.jsx)(n.li,{children:"Validation of the system in simulated and eventually real environments"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The project serves as a foundation for further exploration in humanoid robotics, with opportunities for enhancement in areas like machine learning, advanced manipulation, improved navigation, and richer human-robot interaction models."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Enhance the voice command processing to handle more complex multi-step instructions"}),"\n",(0,r.jsx)(n.li,{children:"Implement a learning mechanism that adapts to user preferences over time"}),"\n",(0,r.jsx)(n.li,{children:"Add computer vision object recognition using a trained model (like YOLO)"}),"\n",(0,r.jsx)(n.li,{children:"Implement a more sophisticated navigation system with dynamic obstacle avoidance"}),"\n",(0,r.jsx)(n.li,{children:"Create a GUI interface for non-verbal interaction with the robot"}),"\n",(0,r.jsx)(n.li,{children:"Integrate the system with a mobile base for full mobility"}),"\n",(0,r.jsx)(n.li,{children:"Add tactile feedback to improve manipulation success rates"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);