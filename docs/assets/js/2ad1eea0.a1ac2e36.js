"use strict";(globalThis.webpackChunkai_textbook_docusaurus=globalThis.webpackChunkai_textbook_docusaurus||[]).push([[900],{2302:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=t(4848),a=t(8453);const o={sidebar_position:4,title:"Nav2 for Path Planning in Humanoid Movement"},i="Nav2: Path Planning for Bipedal Humanoid Movement",s={id:"module-3-ai-brain/nav2-humanoid",title:"Nav2 for Path Planning in Humanoid Movement",description:"Navigation 2 (Nav2) is the next-generation navigation system for ROS 2, designed to provide path planning and navigation capabilities for mobile robots. This section focuses on adapting Nav2 for the specific challenges of bipedal humanoid movement, which requires specialized approaches to path planning and locomotion compared to wheeled robots.",source:"@site/docs/module-3-ai-brain/nav2-humanoid.md",sourceDirName:"module-3-ai-brain",slug:"/module-3-ai-brain/nav2-humanoid",permalink:"/Physical-AI-Humanoid-Robotic-Text-Book/docs/module-3-ai-brain/nav2-humanoid",draft:!1,unlisted:!1,editUrl:"https://github.com/Abdullahkhan90/Physical-AI-Humanoid-Robotic-Text-Book/edit/main/docs/module-3-ai-brain/nav2-humanoid.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Nav2 for Path Planning in Humanoid Movement"},sidebar:"tutorialSidebar",previous:{title:"Isaac ROS for Hardware-Accelerated VSLAM",permalink:"/Physical-AI-Humanoid-Robotic-Text-Book/docs/module-3-ai-brain/visual-slam"},next:{title:"Introduction to Vision-Language-Action (VLA)",permalink:"/Physical-AI-Humanoid-Robotic-Text-Book/docs/module-4-vla/intro"}},l={},c=[{value:"Introduction to Nav2",id:"introduction-to-nav2",level:2},{value:"Challenges in Humanoid Navigation",id:"challenges-in-humanoid-navigation",level:2},{value:"Kinematic Differences",id:"kinematic-differences",level:3},{value:"Terrain Requirements",id:"terrain-requirements",level:3},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Nav2 Architecture for Humanoids",id:"nav2-architecture-for-humanoids",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Humanoid-Specific Modifications",id:"humanoid-specific-modifications",level:3},{value:"Footstep Planning",id:"footstep-planning",level:2},{value:"Introduction to Footstep Planning",id:"introduction-to-footstep-planning",level:3},{value:"Basic Footstep Representation",id:"basic-footstep-representation",level:3},{value:"Footstep Planning Algorithm",id:"footstep-planning-algorithm",level:3},{value:"Nav2 Behavior Trees for Humanoid Navigation",id:"nav2-behavior-trees-for-humanoid-navigation",level:2},{value:"Custom Behavior Tree Nodes",id:"custom-behavior-tree-nodes",level:3},{value:"Humanoid-Specific Recovery Behaviors",id:"humanoid-specific-recovery-behaviors",level:3},{value:"Humanoid Path Planning Approaches",id:"humanoid-path-planning-approaches",level:2},{value:"Topological Path Planning",id:"topological-path-planning",level:3},{value:"Dynamic Path Adjustment",id:"dynamic-path-adjustment",level:3},{value:"Configuring Nav2 for Humanoid Navigation",id:"configuring-nav2-for-humanoid-navigation",level:2},{value:"Costmap Configuration",id:"costmap-configuration",level:3},{value:"Controller Configuration",id:"controller-configuration",level:3},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"Simulation Integration",id:"simulation-integration",level:3},{value:"Safety and Fail-Safe Mechanisms",id:"safety-and-fail-safe-mechanisms",level:2},{value:"Balance Monitoring",id:"balance-monitoring",level:3},{value:"Emergency Procedures",id:"emergency-procedures",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Adaptive Parameter Adjustment",id:"adaptive-parameter-adjustment",level:3},{value:"Integration with Whole Body Control",id:"integration-with-whole-body-control",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"nav2-path-planning-for-bipedal-humanoid-movement",children:"Nav2: Path Planning for Bipedal Humanoid Movement"}),"\n",(0,r.jsx)(n.p,{children:"Navigation 2 (Nav2) is the next-generation navigation system for ROS 2, designed to provide path planning and navigation capabilities for mobile robots. This section focuses on adapting Nav2 for the specific challenges of bipedal humanoid movement, which requires specialized approaches to path planning and locomotion compared to wheeled robots."}),"\n",(0,r.jsx)(n.h2,{id:"introduction-to-nav2",children:"Introduction to Nav2"}),"\n",(0,r.jsx)(n.p,{children:"Nav2 is a complete rewrite of the ROS 1 navigation stack, designed specifically for ROS 2. It provides:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Map management and localization utilities"}),"\n",(0,r.jsx)(n.li,{children:"Path planning for static and dynamic obstacles"}),"\n",(0,r.jsx)(n.li,{children:"Path following with adaptive control"}),"\n",(0,r.jsx)(n.li,{children:"Behavior trees for complex navigation tasks"}),"\n",(0,r.jsx)(n.li,{children:"Modular design allowing custom components"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"challenges-in-humanoid-navigation",children:"Challenges in Humanoid Navigation"}),"\n",(0,r.jsx)(n.p,{children:"Bipedal humanoid robots face unique navigation challenges compared to wheeled robots:"}),"\n",(0,r.jsx)(n.h3,{id:"kinematic-differences",children:"Kinematic Differences"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Bipedal gait requires coordinated leg movements"}),"\n",(0,r.jsx)(n.li,{children:"Center of mass considerations for stability"}),"\n",(0,r.jsx)(n.li,{children:"Different turning mechanics compared to differential drive"}),"\n",(0,r.jsx)(n.li,{children:"Need for footstep planning"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"terrain-requirements",children:"Terrain Requirements"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Negotiating stairs and obstacles requiring stepping"}),"\n",(0,r.jsx)(n.li,{children:"Dynamic balance on uneven surfaces"}),"\n",(0,r.jsx)(n.li,{children:"Need to find stable footholds"}),"\n",(0,r.jsx)(n.li,{children:"Maintaining balance during navigation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fall prevention mechanisms"}),"\n",(0,r.jsx)(n.li,{children:"Stability margins during walking"}),"\n",(0,r.jsx)(n.li,{children:"Reaction to unexpected disturbances"}),"\n",(0,r.jsx)(n.li,{children:"Controlled stopping for balance recovery"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"nav2-architecture-for-humanoids",children:"Nav2 Architecture for Humanoids"}),"\n",(0,r.jsx)(n.h3,{id:"core-components",children:"Core Components"}),"\n",(0,r.jsx)(n.p,{children:"Nav2 consists of several core components that can be adapted for humanoid navigation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"[Map Server] -> [Localizer] -> [Path Planner] -> [Controller] -> [Robot]\r\n      \u2191              \u2191             \u2191            \u2191\r\n[Static Map] <- [Sensor Data] <- [Costmaps] <- [Path Tracker]\n"})}),"\n",(0,r.jsx)(n.h3,{id:"humanoid-specific-modifications",children:"Humanoid-Specific Modifications"}),"\n",(0,r.jsx)(n.p,{children:"The standard Nav2 pipeline requires adaptations for humanoid navigation:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Costmaps"}),": Account for bipedal-specific constraints like step height limits"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Footstep Planners"}),": Generate stable footstep sequences instead of continuous paths"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability Constraints"}),": Ensure center of mass remains within support polygon"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Balance Controllers"}),": Maintain balance during movement execution"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,r.jsx)(n.h3,{id:"introduction-to-footstep-planning",children:"Introduction to Footstep Planning"}),"\n",(0,r.jsx)(n.p,{children:"Unlike wheeled robots that can follow smooth paths, bipedal robots require discrete footstep planning that ensures stability at each step. The footstep planner generates a sequence of foot placements that:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Maintain the robot's balance"}),"\n",(0,r.jsx)(n.li,{children:"Reach the goal location"}),"\n",(0,r.jsx)(n.li,{children:"Avoid obstacles"}),"\n",(0,r.jsx)(n.li,{children:"Respect terrain constraints"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-footstep-representation",children:"Basic Footstep Representation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"struct FootStep {\r\n    // 3D position of the foot placement\r\n    double x, y, z;\r\n    \r\n    // Orientation of the foot\r\n    double roll, pitch, yaw;\r\n    \r\n    // Support polygon (for balance)\r\n    std::vector<Eigen::Vector3d> support_vertices;\r\n    \r\n    // Timing information\r\n    double duration;  // Expected time to execute this step\r\n    \r\n    // Support type (left foot, right foot, double support)\r\n    enum SupportType { LEFT_FOOT, RIGHT_FOOT, DOUBLE_SUPPORT } support_type;\r\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"footstep-planning-algorithm",children:"Footstep Planning Algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class HumanoidFootstepPlanner:\r\n    def __init__(self, robot_params):\r\n        self.robot_params = robot_params\r\n        self.step_height_limit = robot_params.step_height_limit\r\n        self.step_width_limit = robot_params.step_width_limit\r\n        self.com_height = robot_params.com_height\r\n        self.foot_size = robot_params.foot_size\r\n\r\n    def plan_footsteps(self, start_pose, goal_pose, costmap):\r\n        """\r\n        Plan a sequence of footsteps from start to goal\r\n        """\r\n        footsteps = []\r\n        \r\n        # Initial foot positions based on start pose\r\n        left_foot = self.compute_initial_left_foot(start_pose)\r\n        right_foot = self.compute_initial_right_foot(start_pose)\r\n        \r\n        # Path planning in footsteps instead of continuous space\r\n        while not self.reached_goal(left_foot, right_foot, goal_pose):\r\n            # Determine next foot to move based on gait pattern\r\n            next_support_foot = self.determine_support_foot(left_foot, right_foot)\r\n            \r\n            # Plan next footstep considering stability constraints\r\n            next_footstep = self.plan_next_step(\r\n                next_support_foot, \r\n                left_foot, \r\n                right_foot, \r\n                goal_pose, \r\n                costmap\r\n            )\r\n            \r\n            # Verify stability of the planned step\r\n            if self.is_stable(next_footstep, next_support_foot):\r\n                footsteps.append(next_footstep)\r\n                \r\n                # Update current feet positions\r\n                if next_footstep.support_type == \'LEFT_FOOT\':\r\n                    left_foot = next_footstep\r\n                else:\r\n                    right_foot = next_footstep\r\n            else:\r\n                # Handle unstable situation - replan or adjust\r\n                next_footstep = self.adjust_for_stability(\r\n                    next_footstep, \r\n                    next_support_foot, \r\n                    costmap\r\n                )\r\n                footsteps.append(next_footstep)\r\n                \r\n        return footsteps\r\n    \r\n    def is_stable(self, next_step, support_foot):\r\n        """\r\n        Check if the next step maintains stability\r\n        Uses Zero Moment Point (ZMP) or Center of Mass (CoM) criteria\r\n        """\r\n        # Calculate if the projected CoM stays within the support polygon\r\n        com_projection = self.project_com_to_ground(next_step, support_foot)\r\n        support_polygon = self.calculate_support_polygon(support_foot)\r\n        \r\n        return self.point_in_polygon(com_projection, support_polygon)\r\n    \r\n    def plan_next_step(self, current_support_foot, left_foot, right_foot, goal, costmap):\r\n        """\r\n        Plan the next footstep based on goal direction, obstacles, and stability\r\n        """\r\n        # Heuristic for step direction toward goal while avoiding obstacles\r\n        goal_direction = self.calculate_direction_to_goal(goal, current_support_foot)\r\n        \r\n        # Consider terrain traversability\r\n        candidate_steps = self.generate_candidate_steps(current_support_foot, goal_direction)\r\n        \r\n        # Evaluate candidates for safety and efficiency\r\n        best_step = self.select_best_candidate(candidate_steps, costmap, left_foot, right_foot)\r\n        \r\n        return best_step\n'})}),"\n",(0,r.jsx)(n.h2,{id:"nav2-behavior-trees-for-humanoid-navigation",children:"Nav2 Behavior Trees for Humanoid Navigation"}),"\n",(0,r.jsx)(n.p,{children:"Nav2 uses behavior trees to orchestrate navigation tasks. For humanoids, these need to be adapted:"}),"\n",(0,r.jsx)(n.h3,{id:"custom-behavior-tree-nodes",children:"Custom Behavior Tree Nodes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'\x3c!-- humanoid_bt.xml --\x3e\r\n<root main_tree_to_execute="MainTree">\r\n    <BehaviorTree ID="MainTree">\r\n        <Sequence name="nav2_sequence">\r\n            <ClearEntirelyCostmap name="global_clear" service_name="clear_costmap_global"/>\r\n            <GlobalPlanner goal="{goal}" path="{path}"/>\r\n            <ComputePathToPose goal="{goal}" path="{path}"/>\r\n            <FootstepPlanner path="{path}" footsteps="{footsteps}"/>\r\n            \r\n            \x3c!-- Humanoid-specific recovery behaviors --\x3e\r\n            <KeepAliveRecovery/>\r\n            <RebalanceOnPath path="{path}" footsteps="{footsteps}"/>\r\n            \r\n            <Sequence name="follow_waypoints">\r\n                <Fallback name="follow_fallback">\r\n                    <FollowFootsteps path="{path}" footsteps="{footsteps}"/>\r\n                    <RecoveryNode name="balance_recovery">\r\n                        <RecoverBalance/>\r\n                        <TruncPath path="{path}"/>\r\n                        <ComputePathToPose goal="{goal}" path="{path}"/>\r\n                    </RecoveryNode>\r\n                </Fallback>\r\n            </Sequence>\r\n        </Sequence>\r\n    </BehaviorTree>\r\n</root>\n'})}),"\n",(0,r.jsx)(n.h3,{id:"humanoid-specific-recovery-behaviors",children:"Humanoid-Specific Recovery Behaviors"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Recovery behaviors for humanoid robots\r\nclass RebalanceOnPath(BehaviorTreeLeaf):\r\n    def __init__(self, name, options):\r\n        super().__init__(name, options)\r\n        self.balance_threshold = options.balance_threshold\r\n        \r\n    def tick(self):\r\n        # Check if robot is approaching instability\r\n        balance_state = self.get_balance_state()\r\n        \r\n        if balance_state < self.balance_threshold:\r\n            # Execute rebalancing maneuver\r\n            self.execute_rebalance()\r\n            return py_trees.common.Status.SUCCESS\r\n        else:\r\n            # Robot is stable, continue normal navigation\r\n            return py_trees.common.Status.FAILURE\r\n\r\nclass RecoverBalance(BehaviorTreeLeaf):\r\n    def __init__(self, name, options):\r\n        super().__init__(name, options)\r\n        \r\n    def tick(self):\r\n        # Execute balance recovery routine\r\n        # This might include stepping in place, widening stance, etc.\r\n        return py_trees.common.Status.SUCCESS\n"})}),"\n",(0,r.jsx)(n.h2,{id:"humanoid-path-planning-approaches",children:"Humanoid Path Planning Approaches"}),"\n",(0,r.jsx)(n.h3,{id:"topological-path-planning",children:"Topological Path Planning"}),"\n",(0,r.jsx)(n.p,{children:"For humanoid robots, a topological approach often works better than traditional grid-based planning:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class HumanoidTopologicalPlanner:\r\n    def __init__(self):\r\n        self.topological_map = TopologicalMap()\r\n        self.footstep_planner = HumanoidFootstepPlanner()\r\n        \r\n    def plan_path(self, start, goal):\r\n        # Find topologically distinct paths in configuration space\r\n        topological_nodes = self.find_traversable_regions(start, goal)\r\n        \r\n        # For each topological node, plan footstep sequence\r\n        path_candidates = []\r\n        for node in topological_nodes:\r\n            footstep_sequence = self.footstep_planner.plan_footsteps(start, node, self.costmap)\r\n            if footstep_sequence:\r\n                path_candidates.append({\r\n                    'path': [start, node, goal],\r\n                    'footsteps': footstep_sequence,\r\n                    'cost': self.calculate_path_cost(footstep_sequence)\r\n                })\r\n        \r\n        # Select optimal path based on stability, safety, and efficiency\r\n        return self.select_optimal_path(path_candidates)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-path-adjustment",children:"Dynamic Path Adjustment"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots need to dynamically adjust paths based on balance state:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class DynamicHumanoidPathAdjuster:\r\n    def __init__(self):\r\n        self.original_path = None\r\n        self.current_balance_margins = []\r\n        \r\n    def adjust_path_dynamically(self, robot_state, environment_changes):\r\n        """\r\n        Adjust the path based on current robot state and environment\r\n        """\r\n        if self.should_adjust_path(robot_state, environment_changes):\r\n            # Recalculate safest path based on current conditions\r\n            adjusted_footsteps = self.recalculate_with_constraints(\r\n                robot_state,\r\n                self.original_path,\r\n                environment_changes\r\n            )\r\n            \r\n            # Smoothly transition from current execution to new path\r\n            return self.smooth_transition_to_new_path(adjusted_footsteps)\r\n        else:\r\n            # Continue on original path\r\n            return self.original_path\r\n            \r\n    def should_adjust_path(self, robot_state, env_changes):\r\n        """\r\n        Determine if path adjustment is needed\r\n        """\r\n        # Check balance margins\r\n        com_margin = robot_state.com_to_support_polygon_distance\r\n        if com_margin < self.critical_balance_threshold:\r\n            return True\r\n            \r\n        # Check for new obstacles in path\r\n        if self.obstacles_in_current_path(env_changes):\r\n            return True\r\n            \r\n        # Check energy efficiency (if current path is too costly)\r\n        if self.current_path_energy_excessive(robot_state):\r\n            return True\r\n            \r\n        return False\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuring-nav2-for-humanoid-navigation",children:"Configuring Nav2 for Humanoid Navigation"}),"\n",(0,r.jsx)(n.h3,{id:"costmap-configuration",children:"Costmap Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid-specific costmap parameters:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# humanoid_costmap_params.yaml\r\nglobal_costmap:\r\n  ros__parameters:\r\n    update_frequency: 5.0\r\n    publish_frequency: 2.0\r\n    global_frame: map\r\n    robot_base_frame: base_link\r\n    use_sim_time: false\r\n    rolling_window: false\r\n    \r\n    plugins: ["static_layer", "obstacle_layer", "inflation_layer", "step_height_layer"]\r\n    \r\n    static_layer:\r\n      plugin: "nav2_costmap_2d::StaticLayer"\r\n      map_topic: "map"\r\n      transform_tolerance: 0.3\r\n      max_occ_dist: 0.01\r\n    \r\n    obstacle_layer:\r\n      plugin: "nav2_costmap_2d::ObstacleLayer"\r\n      enabled: true\r\n      observation_sources: scan\r\n      scan:\r\n        topic: /laser_scan\r\n        max_obstacle_height: 2.0\r\n        clearing: true\r\n        marking: true\r\n        data_type: "LaserScan"\r\n        inf_is_valid: false\r\n    \r\n    inflation_layer:\r\n      plugin: "nav2_costmap_2d::InflationLayer"\r\n      cost_scaling_factor: 1.5  # Increased for safety\r\n      inflation_radius: 0.8     # Larger for humanoid stability\r\n    \r\n    step_height_layer:  # Humanoid-specific layer\r\n      plugin: "nav2_humanoid_layers::StepHeightLayer"\r\n      max_step_height: 0.2    # Maximum traversable step height\r\n      max_down_height: 0.25   # Maximum step-down height\r\n\r\nlocal_costmap:\r\n  ros__parameters:\r\n    update_frequency: 10.0\r\n    publish_frequency: 5.0\r\n    global_frame: odom\r\n    robot_base_frame: base_link\r\n    rolling_window: true\r\n    width: 6\r\n    height: 6\r\n    resolution: 0.05\r\n    transform_tolerance: 0.3\r\n    \r\n    plugins: ["voxel_layer", "inflation_layer"]\r\n    \r\n    voxel_layer:\r\n      plugin: "nav2_costmap_2d::VoxelLayer"\r\n      enabled: true\r\n      publish_voxel_map: true\r\n      origin_z: 0.0\r\n      z_resolution: 0.2\r\n      z_voxels: 10\r\n      max_obstacle_height: 2.0\r\n      mark_threshold: 0\r\n      observation_sources: scan\r\n      scan:\r\n        topic: /laser_scan\r\n        max_obstacle_height: 2.0\r\n        clearing: true\r\n        marking: true\r\n        data_type: "LaserScan"\r\n        inf_is_valid: false\r\n    \r\n    inflation_layer:\r\n      plugin: "nav2_costmap_2d::InflationLayer"\r\n      cost_scaling_factor: 2.0  # Even higher for local safety\r\n      inflation_radius: 0.5\n'})}),"\n",(0,r.jsx)(n.h3,{id:"controller-configuration",children:"Controller Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Controllers adapted for humanoid locomotion:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'# humanoid_controllers.yaml\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: false\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.05\r\n    min_y_velocity_threshold: 0.05\r\n    min_theta_velocity_threshold: 0.05\r\n    \r\n    # Humanoid-specific controllers\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugin: "goal_checker"\r\n    \r\n    controller_plugins: ["HumanoidFollowPath"]\r\n    \r\n    HumanoidFollowPath:\r\n      plugin: "nav2_mppi::HumanoidController"\r\n      # Humanoid-specific parameters\r\n      step_size_max: 0.3        # Maximum step size\r\n      foot_lift_height: 0.05    # Height to lift foot when stepping\r\n      step_timing: 0.8          # Duration of each step\r\n      balance_margin: 0.1       # Safety margin for COM over support polygon\r\n      gait_pattern: "natural_walk"  # Desired walking pattern\n'})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"simulation-integration",children:"Simulation Integration"}),"\n",(0,r.jsx)(n.p,{children:"Before deploying on a real humanoid, extensive simulation is crucial:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class HumanoidNavigationSimulator:\r\n    def __init__(self):\r\n        self.simulator = GazeboSimulator()\r\n        self.robot_model = self.load_humanoid_model("atlas", "op3", "romeo")\r\n        self.terrain_generator = VariedTerrainGenerator()\r\n        self.nav_system = Nav2System()\r\n        \r\n    def simulate_navigation_scenario(self, scenario_params):\r\n        """\r\n        Simulate navigation in various challenging scenarios\r\n        """\r\n        # Generate varied terrain with stairs, slopes, obstacles\r\n        terrain = self.terrain_generator.generate(scenario_params)\r\n        \r\n        # Set up humanoid model with correct dynamics\r\n        humanoid = self.robot_model.spawn(terrain)\r\n        \r\n        # Define navigation task\r\n        start = self.sample_free_space(terrain)\r\n        goal = self.sample_free_space(terrain, min_distance=5.0)\r\n        \r\n        # Run navigation\r\n        start_time = time.time()\r\n        result = self.nav_system.navigate(humanoid, start, goal)\r\n        end_time = time.time()\r\n        \r\n        # Evaluate performance\r\n        performance = {\r\n            \'success\': result.success,\r\n            \'time\': end_time - start_time,\r\n            \'energy\': self.calculate_energy_consumption(result),\r\n            \'stability\': self.calculate_stability_metrics(result),\r\n            \'path_efficiency\': self.calculate_path_efficiency(result, start, goal)\r\n        }\r\n        \r\n        return performance\n'})}),"\n",(0,r.jsx)(n.h2,{id:"safety-and-fail-safe-mechanisms",children:"Safety and Fail-Safe Mechanisms"}),"\n",(0,r.jsx)(n.h3,{id:"balance-monitoring",children:"Balance Monitoring"}),"\n",(0,r.jsx)(n.p,{children:"Continuous monitoring of balance state:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class BalanceMonitor:\r\n    def __init__(self):\r\n        self.com_subscriber = rospy.Subscriber(\'/robot/com_state\', ComState, self.com_callback)\r\n        self.imu_subscriber = rospy.Subscriber(\'/imu/data\', Imu, self.imu_callback)\r\n        self.balance_threshold = 0.05  # meters from support polygon\r\n        \r\n    def com_callback(self, data):\r\n        self.current_com = [data.x, data.y, data.z]\r\n        \r\n    def imu_callback(self, data):\r\n        self.imu_orientation = [data.orientation.x, data.orientation.y, \r\n                                data.orientation.z, data.orientation.w]\r\n        \r\n    def is_balanced(self):\r\n        """Check if robot is currently balanced"""\r\n        support_polygon = self.calculate_current_support_polygon()\r\n        com_proj = self.project_com_to_ground()\r\n        \r\n        # Calculate distance from CoM projection to edge of support polygon\r\n        distance_to_edge = self.distance_com_to_polygon_edge(com_proj, support_polygon)\r\n        \r\n        return distance_to_edge > self.balance_threshold\n'})}),"\n",(0,r.jsx)(n.h3,{id:"emergency-procedures",children:"Emergency Procedures"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class HumanoidEmergencyHandler:\r\n    def __init__(self):\r\n        self.emergency_publisher = rospy.Publisher(\'/emergency_stop\', Bool, queue_size=1)\r\n        self.balance_monitor = BalanceMonitor()\r\n        \r\n    def monitor_safety(self):\r\n        """Continuously monitor for emergency situations"""\r\n        while not rospy.is_shutdown():\r\n            if not self.balance_monitor.is_balanced():\r\n                self.execute_emergency_procedure("imbalance_detected")\r\n                \r\n            if self.detect_collision():\r\n                self.execute_emergency_procedure("collision_detected")\r\n                \r\n            rospy.sleep(0.01)  # 100Hz monitoring\r\n            \r\n    def execute_emergency_procedure(self, event_type):\r\n        """Execute appropriate emergency procedure"""\r\n        if event_type == "imbalance_detected":\r\n            # Attempt dynamic stabilization\r\n            if self.can_stabilize():\r\n                self.attempt_dynamic_stabilization()\r\n            else:\r\n                # Safely lower to ground\r\n                self.exec_safe_landing_procedure()\r\n        elif event_type == "collision_detected":\r\n            # Stop all motion and assess damage\r\n            self.emergency_stop()\r\n            \r\n    def can_stabilize(self):\r\n        """Determine if robot can recover balance"""\r\n        # Check if center of mass is recoverable\r\n        # Check if feasible foot placement exists\r\n        # Check if actuators have available torque\r\n        return self.check_recoverability()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"adaptive-parameter-adjustment",children:"Adaptive Parameter Adjustment"}),"\n",(0,r.jsx)(n.p,{children:"Adjust navigation parameters based on terrain and robot state:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class AdaptiveHumanoidNavigator:\r\n    def __init__(self):\r\n        self.terrain_classifier = TerrainClassifier()\r\n        self.robot_state_observer = RobotStateObserver()\r\n        self.path_adjuster = DynamicHumanoidPathAdjuster()\r\n        \r\n    def adjust_parameters_for_terrain(self, current_terrain):\r\n        """Adjust Nav2 parameters based on detected terrain"""\r\n        terrain_type = self.terrain_classifier.classify(current_terrain)\r\n        \r\n        if terrain_type == "uneven":\r\n            # Increase safety margins and slow down\r\n            self.nav_system.set_param("inflation_radius", 0.8)  # Wider safety buffer\r\n            self.nav_system.set_param("step_size_max", 0.15)   # Shorter steps\r\n            self.nav_system.set_param("balance_margin", 0.15)  # More conservative balance\r\n            \r\n        elif terrain_type == "stairs":\r\n            # Configure for stair climbing\r\n            self.nav_system.set_param("step_size_max", 0.25)  # Adjust for step heights\r\n            self.nav_system.set_param("foot_lift_height", 0.1)  # Higher foot lift\r\n            \r\n        elif terrain_type == "narrow_passage":\r\n            # Configure single-file walking\r\n            self.nav_system.set_param("step_size_max", 0.1)   # Very conservative\r\n            self.nav_system.set_param("balance_margin", 0.2)  # Extra stability\r\n        \r\n        # Update other relevant parameters\r\n        self.update_localization_parameters(terrain_type)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-whole-body-control",children:"Integration with Whole Body Control"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid navigation must integrate with whole-body control systems:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class IntegratedHumanoidNavigation:\r\n    def __init__(self):\r\n        self.navigation_system = Nav2System()\r\n        self.whole_body_controller = WholeBodyController()\r\n        self.footstep_planner = HumanoidFootstepPlanner()\r\n        \r\n    def coordinated_navigation(self, goal):\r\n        """\r\n        Coordinate navigation path following with whole-body control\r\n        """\r\n        # Plan global path\r\n        path = self.navigation_system.plan_path(goal)\r\n        \r\n        # Convert to footstep sequence\r\n        footsteps = self.footstep_planner.plan_footsteps_from_path(path)\r\n        \r\n        # Execute with whole-body coordination\r\n        for footstep in footsteps:\r\n            # Plan whole-body motion to execute footstep\r\n            whole_body_plan = self.whole_body_controller.plan_motion_to_footstep(footstep)\r\n            \r\n            # Execute coordinated motion\r\n            self.whole_body_controller.execute(whole_body_plan)\r\n            \r\n            # Monitor for errors and adjust if needed\r\n            if not self.verify_execution_success():\r\n                self.replan_from_current_state()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Adapting Nav2 for humanoid navigation requires significant modifications to account for the unique challenges of bipedal locomotion. The key differences include the need for footstep planning instead of continuous path following, stability considerations during movement, and integration with whole-body control systems. With proper implementation of these humanoid-specific components, Nav2 can effectively provide safe and efficient navigation for bipedal robots."}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Implement a basic footstep planner for a simple humanoid model"}),"\n",(0,r.jsx)(n.li,{children:"Configure Nav2 with humanoid-specific costmap layers"}),"\n",(0,r.jsx)(n.li,{children:"Develop a simulation scenario with stairs and uneven terrain"}),"\n",(0,r.jsx)(n.li,{children:"Implement balance monitoring and emergency procedures"}),"\n",(0,r.jsx)(n.li,{children:"Create adaptive parameter adjustment based on terrain classification"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(6540);const a={},o=r.createContext(a);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);