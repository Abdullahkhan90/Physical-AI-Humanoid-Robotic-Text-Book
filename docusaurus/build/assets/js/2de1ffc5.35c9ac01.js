"use strict";(globalThis.webpackChunkai_textbook_docusaurus=globalThis.webpackChunkai_textbook_docusaurus||[]).push([[963],{2918:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var t=r(4848),a=r(8453);const i={sidebar_position:3,title:"Cognitive Planning with LLMs"},o="Cognitive Planning: Using LLMs to Translate Natural Language into ROS 2 Actions",s={id:"module-4-vla/cognitive-planning",title:"Cognitive Planning with LLMs",description:"Large Language Models (LLMs) have emerged as powerful tools for natural language understanding and generation. In robotics, they can serve as high-level cognitive planners that interpret natural language commands and translate them into sequences of executable robot actions. This section explores how to integrate LLMs into robotic systems for cognitive planning.",source:"@site/docs/module-4-vla/cognitive-planning.md",sourceDirName:"module-4-vla",slug:"/module-4-vla/cognitive-planning",permalink:"/Physical-AI-Humanoid_Robotic-Text-Book/docs/module-4-vla/cognitive-planning",draft:!1,unlisted:!1,editUrl:"https://github.com/Abdullahkhan90/Physical-AI-Humanoid-Robotic-Text-Book/edit/main/docs/module-4-vla/cognitive-planning.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Cognitive Planning with LLMs"},sidebar:"tutorialSidebar",previous:{title:"Voice-to-Action with OpenAI Whisper",permalink:"/Physical-AI-Humanoid_Robotic-Text-Book/docs/module-4-vla/voice-to-action"},next:{title:"Capstone Project - The Autonomous Humanoid",permalink:"/Physical-AI-Humanoid_Robotic-Text-Book/docs/module-4-vla/capstone-project"}},l={},c=[{value:"Introduction to Cognitive Planning in Robotics",id:"introduction-to-cognitive-planning-in-robotics",level:2},{value:"Role of LLMs in Cognitive Planning",id:"role-of-llms-in-cognitive-planning",level:2},{value:"Advantages of LLMs for Planning",id:"advantages-of-llms-for-planning",level:3},{value:"Limitations and Mitigations",id:"limitations-and-mitigations",level:3},{value:"Architecture for LLM-Based Cognitive Planning",id:"architecture-for-llm-based-cognitive-planning",level:2},{value:"System Components",id:"system-components",level:3},{value:"Integration with ROS 2",id:"integration-with-ros-2",level:3},{value:"Implementation Approaches",id:"implementation-approaches",level:2},{value:"Prompt Engineering",id:"prompt-engineering",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"Integration with Robot Control Systems",id:"integration-with-robot-control-systems",level:2},{value:"ROS 2 Action Server Pattern",id:"ros-2-action-server-pattern",level:3},{value:"Safety and Validation",id:"safety-and-validation",level:2},{value:"Action Validation",id:"action-validation",level:3},{value:"Performance and Efficiency Optimization",id:"performance-and-efficiency-optimization",level:2},{value:"Caching",id:"caching",level:3},{value:"Local Models",id:"local-models",level:3},{value:"Error Handling and Recovery",id:"error-handling-and-recovery",level:2},{value:"Plan Failure Handling",id:"plan-failure-handling",level:3},{value:"Evaluation and Improvement",id:"evaluation-and-improvement",level:2},{value:"Metrics for Cognitive Planning",id:"metrics-for-cognitive-planning",level:3},{value:"Continuous Learning",id:"continuous-learning",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"cognitive-planning-using-llms-to-translate-natural-language-into-ros-2-actions",children:"Cognitive Planning: Using LLMs to Translate Natural Language into ROS 2 Actions"}),"\n",(0,t.jsx)(e.p,{children:"Large Language Models (LLMs) have emerged as powerful tools for natural language understanding and generation. In robotics, they can serve as high-level cognitive planners that interpret natural language commands and translate them into sequences of executable robot actions. This section explores how to integrate LLMs into robotic systems for cognitive planning."}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-cognitive-planning-in-robotics",children:"Introduction to Cognitive Planning in Robotics"}),"\n",(0,t.jsx)(e.p,{children:"Cognitive planning in robotics involves high-level reasoning that bridges natural language commands to low-level robot actions. It requires:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understanding natural language commands in context"}),"\n",(0,t.jsx)(e.li,{children:"Breaking down complex tasks into manageable steps"}),"\n",(0,t.jsx)(e.li,{children:"Maintaining situational awareness of the environment"}),"\n",(0,t.jsx)(e.li,{children:"Generating executable sequences of robot actions"}),"\n",(0,t.jsx)(e.li,{children:"Handling unexpected situations and exceptions"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"role-of-llms-in-cognitive-planning",children:"Role of LLMs in Cognitive Planning"}),"\n",(0,t.jsx)(e.h3,{id:"advantages-of-llms-for-planning",children:"Advantages of LLMs for Planning"}),"\n",(0,t.jsx)(e.p,{children:"LLMs bring several advantages to cognitive planning:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Commonsense Reasoning"}),": LLMs possess general world knowledge that can inform action planning"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Natural Language Understanding"}),": Direct interpretation of human commands without specialized grammars"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flexibility"}),": Ability to handle varied and novel instruction formats"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Context Awareness"}),": Understanding of temporal and spatial relationships"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"limitations-and-mitigations",children:"Limitations and Mitigations"}),"\n",(0,t.jsx)(e.p,{children:"However, LLMs also present challenges:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Hallucinations"}),": Producing plausible-sounding but incorrect plans"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Lack of Real-Time Awareness"}),": Not aware of current robot state or environment"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safety Concerns"}),": Potential to generate unsafe action sequences"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Computational Demands"}),": Resource-intensive inference"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"architecture-for-llm-based-cognitive-planning",children:"Architecture for LLM-Based Cognitive Planning"}),"\n",(0,t.jsx)(e.h3,{id:"system-components",children:"System Components"}),"\n",(0,t.jsx)(e.p,{children:"A typical LLM-based cognitive planning system includes:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"[User Command] ->\r\n[Natural Language Parser] ->\r\n[LLM Planner] ->\r\n[Action Sequence Generator] ->\r\n[Robot Execution Layer] ->\r\n[Environment Perception] <- Feedback Loop\n"})}),"\n",(0,t.jsx)(e.h3,{id:"integration-with-ros-2",children:"Integration with ROS 2"}),"\n",(0,t.jsx)(e.p,{children:"The system typically integrates with ROS 2 through:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Services for high-level command requests"}),"\n",(0,t.jsx)(e.li,{children:"Action servers for long-running tasks"}),"\n",(0,t.jsx)(e.li,{children:"Publishers/subscribers for state monitoring"}),"\n",(0,t.jsx)(e.li,{children:"Transform system for spatial reasoning"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"implementation-approaches",children:"Implementation Approaches"}),"\n",(0,t.jsx)(e.h3,{id:"prompt-engineering",children:"Prompt Engineering"}),"\n",(0,t.jsx)(e.p,{children:"Effective cognitive planning relies heavily on well-engineered prompts:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'def create_planning_prompt(user_command, robot_capabilities, environment_state):\r\n    """\r\n    Creates a structured prompt for the LLM cognitive planner\r\n    """\r\n    prompt = f"""\r\n    You are a cognitive planner for a robot. Your job is to translate human commands into executable robot actions.\r\n    \r\n    Current environment state:\r\n    {environment_state}\r\n    \r\n    Available robot capabilities:\r\n    {robot_capabilities}\r\n    \r\n    Human command: "{user_command}"\r\n    \r\n    Provide the sequence of actions to execute the command. Format your response as:\r\n    1. Action: [action_name] Parameters: [parameters]\r\n    2. Action: [action_name] Parameters: [parameters]\r\n    ...\r\n    \r\n    Only provide actions that the robot is capable of performing.\r\n    """\r\n    \r\n    return prompt\n'})}),"\n",(0,t.jsx)(e.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import openai  # or another LLM API\r\nfrom typing import List, Dict, Any\r\nimport json\r\n\r\nclass LLMBasedCognitivePlanner:\r\n    def __init__(self, api_key: str, model: str = "gpt-3.5-turbo"):\r\n        self.api_key = api_key\r\n        self.model = model\r\n        openai.api_key = api_key\r\n        \r\n        # Define known robot capabilities\r\n        self.known_capabilities = [\r\n            "move_to_location",\r\n            "pick_object",\r\n            "place_object",\r\n            "navigate",\r\n            "detect_object",\r\n            "grasp",\r\n            "release",\r\n            "follow_route"\r\n        ]\r\n        \r\n    def plan_action_sequence(self, natural_language_command: str, \r\n                           robot_state: Dict[str, Any],\r\n                           environment_state: Dict[str, Any]) -> List[Dict[str, Any]]:\r\n        """\r\n        Generate action sequence from natural language command\r\n        """\r\n        # Create planning prompt\r\n        prompt = self._create_planning_prompt(\r\n            natural_language_command,\r\n            robot_state,\r\n            environment_state\r\n        )\r\n        \r\n        # Call LLM\r\n        response = openai.ChatCompletion.create(\r\n            model=self.model,\r\n            messages=[{"role": "user", "content": prompt}]\r\n        )\r\n        \r\n        # Parse response into action sequence\r\n        response_text = response.choices[0].message[\'content\']\r\n        actions = self._parse_actions(response_text)\r\n        \r\n        # Validate actions\r\n        valid_actions = self._validate_action_sequence(actions)\r\n        \r\n        return valid_actions\r\n    \r\n    def _create_planning_prompt(self, command: str, \r\n                                robot_state: Dict[str, Any],\r\n                                env_state: Dict[str, Any]) -> str:\r\n        """Create a structured prompt for the LLM"""\r\n        # Implementation of prompt creation\r\n        # Include robot capabilities, environment context, etc.\r\n        prompt = f"""\r\n        As a cognitive planning system for a robot, translate this natural language command into a sequence of actions:\r\n        Command: "{command}"\r\n        \r\n        Environment context:\r\n        - Objects: {[obj[\'name\'] for obj in env_state.get(\'objects\', [])]}\r\n        - Locations: {[loc[\'name\'] for loc in env_state.get(\'locations\', [])]}\r\n        - Robot position: {robot_state.get(\'position\', \'unknown\')}\r\n        - Robot battery: {robot_state.get(\'battery_level\', \'unknown\')}%\r\n        \r\n        Available actions:\r\n        - move_to_location: Move robot to a named location\r\n        - pick_object: Pick up an object by name\r\n        - place_object: Place held object at location\r\n        - navigate: Navigate to coordinates\r\n        - detect_object: Look for an object\r\n        - grasp: Grasp current object\r\n        - release: Release current object\r\n        - follow_route: Follow predefined route\r\n        \r\n        Provide the plan as numbered steps in this format:\r\n        1. move_to_location: location="kitchen"\r\n        2. detect_object: object="cup"\r\n        3. pick_object: object="cup"\r\n        4. move_to_location: location="table"\r\n        5. place_object: location="table"\r\n\r\n        Return only the action sequence, nothing else.\r\n        """\r\n        return prompt\r\n    \r\n    def _parse_actions(self, response_text: str) -> List[Dict[str, Any]]:\r\n        """Parse the LLM response into executable actions"""\r\n        actions = []\r\n        \r\n        # Simple regex-based parser (more sophisticated approaches exist)\r\n        import re\r\n        \r\n        # Match pattern like: "1. action_name: param1=value1, param2=value2"\r\n        pattern = r\'(\\d+)\\.\\s*([a-zA-Z_][a-zA-Z0-9_]*)\\s*:\\s*(.*)\'\r\n        \r\n        matches = re.findall(pattern, response_text)\r\n        \r\n        for match in matches:\r\n            step_num, action_name, params_str = match\r\n            \r\n            # Parse parameters\r\n            params = {}\r\n            if params_str.strip():\r\n                # Split on commas that are not within quotes\r\n                param_pairs = [p.strip() for p in params_str.split(\',\')]\r\n                for pair in param_pairs:\r\n                    if \'=\' in pair:\r\n                        key, value = pair.split(\'=\', 1)\r\n                        key = key.strip()\r\n                        value = value.strip().strip(\'"\\\'\')\r\n                        \r\n                        # Try to convert to appropriate type\r\n                        if value.lower() == \'true\':\r\n                            value = True\r\n                        elif value.lower() == \'false\':\r\n                            value = False\r\n                        elif value.isdigit():\r\n                            value = int(value)\r\n                        else:\r\n                            try:\r\n                                value = float(value)\r\n                            except ValueError:\r\n                                pass  # Keep as string\r\n                        \r\n                        params[key] = value\r\n            \r\n            action = {\r\n                "name": action_name,\r\n                "parameters": params,\r\n                "step_number": int(step_num)\r\n            }\r\n            actions.append(action)\r\n        \r\n        return actions\r\n    \r\n    def _validate_action_sequence(self, action_sequence: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\r\n        """Validate that actions are executable by the robot"""\r\n        valid_actions = []\r\n        \r\n        for action in action_sequence:\r\n            action_name = action[\'name\']\r\n            \r\n            if action_name not in self.known_capabilities:\r\n                print(f"Warning: Unknown action \'{action_name}\' in sequence, skipping")\r\n                continue\r\n            \r\n            # Validate parameters if needed\r\n            valid_actions.append(action)\r\n        \r\n        return valid_actions\n'})}),"\n",(0,t.jsx)(e.h2,{id:"integration-with-robot-control-systems",children:"Integration with Robot Control Systems"}),"\n",(0,t.jsx)(e.h3,{id:"ros-2-action-server-pattern",children:"ROS 2 Action Server Pattern"}),"\n",(0,t.jsx)(e.p,{children:"For complex tasks, integrate with ROS 2 action servers:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom your_robot_interfaces.action import ExecuteCommand\r\nfrom std_msgs.msg import String\r\n\r\nclass CognitivePlanningActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__(\'cognitive_planning_server\')\r\n        \r\n        # Initialize the LLM planner\r\n        self.planner = LLMBasedCognitivePlanner(api_key=your_api_key)\r\n        \r\n        # Create action server\r\n        self._action_server = ActionServer(\r\n            self,\r\n            ExecuteCommand,\r\n            \'execute_command\',\r\n            self.execute_command_callback)\r\n        \r\n        # Robot state and environment publishers/subscribers\r\n        self.state_publisher = self.create_publisher(String, \'cognitive_planner/state\', 10)\r\n        \r\n    def execute_command_callback(self, goal_handle):\r\n        """Execute a natural language command"""\r\n        self.get_logger().info(f\'Executing command: {goal_handle.request.command}\')\r\n        \r\n        # Get current robot and environment state\r\n        robot_state = self._get_robot_state()\r\n        env_state = self._get_environment_state()\r\n        \r\n        # Plan action sequence\r\n        try:\r\n            action_sequence = self.planner.plan_action_sequence(\r\n                goal_handle.request.command,\r\n                robot_state,\r\n                env_state\r\n            )\r\n            \r\n            # Execute the sequence\r\n            for i, action in enumerate(action_sequence):\r\n                # Update feedback\r\n                feedback_msg = ExecuteCommand.Feedback()\r\n                feedback_msg.current_step = f"Executing: {action[\'name\']} ({i+1}/{len(action_sequence)})"\r\n                goal_handle.publish_feedback(feedback_msg)\r\n                \r\n                # Execute action\r\n                success = self._execute_single_action(action)\r\n                if not success:\r\n                    goal_handle.abort()\r\n                    result = ExecuteCommand.Result()\r\n                    result.success = False\r\n                    result.message = f"Failed to execute action: {action}"\r\n                    return result\r\n        \r\n            # Complete successfully\r\n            goal_handle.succeed()\r\n            result = ExecuteCommand.Result()\r\n            result.success = True\r\n            result.message = f"Successfully executed command with {len(action_sequence)} actions"\r\n            return result\r\n            \r\n        except Exception as e:\r\n            self.get_logger().error(f\'Error executing command: {str(e)}\')\r\n            goal_handle.abort()\r\n            result = ExecuteCommand.Result()\r\n            result.success = False\r\n            result.message = f"Error during planning: {str(e)}"\r\n            return result\r\n    \r\n    def _execute_single_action(self, action: Dict[str, Any]) -> bool:\r\n        """Execute a single action using ROS 2 interfaces"""\r\n        # This would contain the actual ROS 2 service calls and action executions\r\n        action_name = action[\'name\']\r\n        params = action[\'parameters\']\r\n        \r\n        # Example mapping to ROS 2 services\r\n        if action_name == "move_to_location":\r\n            return self._move_to_location(params.get("location"))\r\n        elif action_name == "pick_object":\r\n            return self._pick_object(params.get("object"))\r\n        elif action_name == "place_object":\r\n            return self._place_object(params.get("location"))\r\n        # Additional action mappings...\r\n        \r\n        return False  # Unknown action\r\n    \r\n    def _get_robot_state(self) -> Dict[str, Any]:\r\n        """Get current robot state"""\r\n        # Implementation would query robot state topics\r\n        return {\r\n            "position": {"x": 0.0, "y": 0.0, "theta": 0.0},\r\n            "battery_level": 85,\r\n            "gripper_status": "open"\r\n        }\r\n    \r\n    def _get_environment_state(self) -> Dict[str, Any]:\r\n        """Get current environment state"""\r\n        # Implementation would query environment mapping topics\r\n        return {\r\n            "objects": [\r\n                {"name": "cup", "position": {"x": 1.0, "y": 1.0}},\r\n                {"name": "box", "position": {"x": 2.0, "y": 0.5}}\r\n            ],\r\n            "locations": [\r\n                {"name": "kitchen", "coordinates": {"x": 5.0, "y": 5.0}},\r\n                {"name": "table", "coordinates": {"x": 3.0, "y": 2.0}}\r\n            ]\r\n        }\n'})}),"\n",(0,t.jsx)(e.h2,{id:"safety-and-validation",children:"Safety and Validation"}),"\n",(0,t.jsx)(e.h3,{id:"action-validation",children:"Action Validation"}),"\n",(0,t.jsx)(e.p,{children:"Before executing commands generated by LLMs, implement validation steps:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class ActionSafetyValidator:\r\n    def __init__(self):\r\n        # Define safety constraints\r\n        self.forbidden_objects = ["person", "face", "hand", "eye"]  # Objects that shouldn\'t be grabbed\r\n        self.safe_zones = []  # Define allowed navigation areas\r\n        self.max_velocity = 0.5  # Restrict robot velocities\r\n        self.critical_actions = ["open_valve", "close_door"]  # Actions requiring extra validation\r\n    \r\n    def validate_action_sequence(self, action_sequence, current_state, environment_state):\r\n        """Validate an action sequence for safety"""\r\n        for action in action_sequence:\r\n            if not self._is_action_safe(action, current_state, environment_state):\r\n                return False, f"Unsafe action: {action[\'name\']} with parameters {action[\'parameters\']}"\r\n        \r\n        return True, "All actions are safe"\r\n    \r\n    def _is_action_safe(self, action, current_state, environment_state):\r\n        """Check if a single action is safe to execute"""\r\n        action_name = action[\'name\']\r\n        params = action[\'parameters\']\r\n        \r\n        # Check for forbidden object names\r\n        if \'object\' in params:\r\n            obj_name = params[\'object\'].lower()\r\n            if any(forbidden in obj_name for forbidden in self.forbidden_objects):\r\n                return False\r\n        \r\n        # Check navigation targets\r\n        if action_name == \'move_to_location\' and \'location\' in params:\r\n            if not self._is_location_safe(params[\'location\'], environment_state):\r\n                return False\r\n        \r\n        # Check critical actions\r\n        if action_name in self.critical_actions:\r\n            # Require additional human confirmation for critical actions\r\n            return False  # For now, block all critical actions\r\n        \r\n        return True\r\n    \r\n    def _is_location_safe(self, location, environment_state):\r\n        """Check if a location is in safe zones"""\r\n        # Implementation would check if location is in predefined safe zones\r\n        return True\n'})}),"\n",(0,t.jsx)(e.h2,{id:"performance-and-efficiency-optimization",children:"Performance and Efficiency Optimization"}),"\n",(0,t.jsx)(e.h3,{id:"caching",children:"Caching"}),"\n",(0,t.jsx)(e.p,{children:"Cache frequent command patterns to reduce LLM API calls:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from functools import lru_cache\r\n\r\nclass CachedCognitivePlanner(LLMBasedCognitivePlanner):\r\n    @lru_cache(maxsize=100)\r\n    def plan_with_cache(self, command: str, robot_state_hash: str, env_state_hash: str):\r\n        """Cached version of planning method"""\r\n        # Convert hashes back to actual state objects\r\n        # Call the parent planning method\r\n        pass\n'})}),"\n",(0,t.jsx)(e.h3,{id:"local-models",children:"Local Models"}),"\n",(0,t.jsx)(e.p,{children:"For privacy and efficiency, consider using local LLM implementations:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'from transformers import pipeline\r\n\r\nclass LocalCognitivePlanner:\r\n    def __init__(self, model_name="microsoft/DialoGPT-medium"):\r\n        self.generator = pipeline(\r\n            "text-generation",\r\n            model=model_name,\r\n            tokenizer=model_name\r\n        )\r\n    \r\n    def plan_local(self, command: str):\r\n        """Plan using local model"""\r\n        # Implementation would use local LLM\r\n        pass\n'})}),"\n",(0,t.jsx)(e.h2,{id:"error-handling-and-recovery",children:"Error Handling and Recovery"}),"\n",(0,t.jsx)(e.h3,{id:"plan-failure-handling",children:"Plan Failure Handling"}),"\n",(0,t.jsx)(e.p,{children:"Implement strategies for when generated plans fail:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class RobustCognitivePlanner:\r\n    def __init__(self):\r\n        self.planner = LLMBasedCognitivePlanner()\r\n        self.validator = ActionSafetyValidator()\r\n    \r\n    def execute_with_recovery(self, command: str):\r\n        """Execute command with error recovery"""\r\n        max_retries = 3\r\n        retry_count = 0\r\n        \r\n        while retry_count < max_retries:\r\n            try:\r\n                # Plan and validate\r\n                action_seq = self.planner.plan_action_sequence(\r\n                    command,\r\n                    self._get_current_state(),\r\n                    self._get_env_state()\r\n                )\r\n                \r\n                is_safe, reason = self.validator.validate_action_sequence(\r\n                    action_seq, \r\n                    self._get_current_state(), \r\n                    self._get_env_state()\r\n                )\r\n                \r\n                if not is_safe:\r\n                    raise ValueError(f"Plan unsafe: {reason}")\r\n                \r\n                # Execute with monitoring\r\n                result = self._execute_with_monitoring(action_seq)\r\n                \r\n                if result.success:\r\n                    return result\r\n                else:\r\n                    # Plan execution failed, try again with environmental context\r\n                    retry_count += 1\r\n                    command = self._refine_command_for_retry(command, result.failure_reason)\r\n            \r\n            except Exception as e:\r\n                retry_count += 1\r\n                if retry_count >= max_retries:\r\n                    raise RuntimeError(f"Command failed after {max_retries} attempts: {str(e)}")\r\n    \r\n    def _refine_command_for_retry(self, original_command: str, failure_reason: str):\r\n        """Adjust command based on failure reason"""\r\n        return f"{original_command}. Note: {failure_reason}. Please adjust your plan accordingly."\n'})}),"\n",(0,t.jsx)(e.h2,{id:"evaluation-and-improvement",children:"Evaluation and Improvement"}),"\n",(0,t.jsx)(e.h3,{id:"metrics-for-cognitive-planning",children:"Metrics for Cognitive Planning"}),"\n",(0,t.jsx)(e.p,{children:"Evaluate the effectiveness of your cognitive planning system:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task Success Rate"}),": Percentage of commands successfully executed"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Plan Accuracy"}),": How closely generated plans match intended actions"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Response Time"}),": Time from command to initial action"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"User Satisfaction"}),": Subjective rating of how well the system understood commands"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"continuous-learning",children:"Continuous Learning"}),"\n",(0,t.jsx)(e.p,{children:"Implement feedback mechanisms to improve over time:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:'class SelfImprovingPlanner:\r\n    def __init__(self):\r\n        self.planner = LLMBasedCognitivePlanner()\r\n        self.feedback_archive = []\r\n    \r\n    def record_interaction(self, command, plan, execution_result, human_feedback):\r\n        """Record interaction for future learning"""\r\n        interaction = {\r\n            "command": command,\r\n            "generated_plan": plan,\r\n            "execution_result": execution_result,\r\n            "feedback": human_feedback,\r\n            "timestamp": time.time()\r\n        }\r\n        \r\n        self.feedback_archive.append(interaction)\r\n    \r\n    def refine_with_feedback(self):\r\n        """Use feedback to improve future planning"""\r\n        # Implementation would analyze successful patterns in feedback archive\r\n        pass\n'})}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"LLM-based cognitive planning offers significant potential for natural human-robot interaction by directly translating natural language commands into robot actions. However, successful implementation requires careful attention to safety, validation, and error handling. The approach works best when combined with traditional robotics systems that provide environmental awareness and safety guarantees."}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:'Implement a simple cognitive planner that converts "Bring me the red cup from the kitchen" into a sequence of ROS 2 actions'}),"\n",(0,t.jsx)(e.li,{children:"Add safety validation to prevent the robot from attempting to grasp forbidden objects"}),"\n",(0,t.jsx)(e.li,{children:"Create a feedback mechanism to refine plans based on execution failures"}),"\n",(0,t.jsx)(e.li,{children:"Implement caching for frequently executed commands"}),"\n",(0,t.jsx)(e.li,{children:"Design a multimodal cognitive planner that considers both speech and visual input"}),"\n"]})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>s});var t=r(6540);const a={},i=t.createContext(a);function o(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);